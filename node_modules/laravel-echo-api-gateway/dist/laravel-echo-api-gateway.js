function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

class Connector {
    /**
     * Create a new class instance.
     */
    constructor(options) {
        /**
         * Default connector options.
         */
        this._defaultOptions = {
            auth: {
                headers: {},
            },
            authEndpoint: '/broadcasting/auth',
            broadcaster: 'pusher',
            csrfToken: null,
            host: null,
            key: null,
            namespace: 'App.Events',
        };
        this.setOptions(options);
        this.connect();
    }
    /**
     * Merge the custom options with the defaults.
     */
    setOptions(options) {
        this.options = Object.assign(this._defaultOptions, options);
        if (this.csrfToken()) {
            this.options.auth.headers['X-CSRF-TOKEN'] = this.csrfToken();
        }
        return options;
    }
    /**
     * Extract the CSRF token from the page.
     */
    csrfToken() {
        let selector;
        if (typeof window !== 'undefined' && window['Laravel'] && window['Laravel'].csrfToken) {
            return window['Laravel'].csrfToken;
        }
        else if (this.options.csrfToken) {
            return this.options.csrfToken;
        }
        else if (typeof document !== 'undefined' &&
            typeof document.querySelector === 'function' &&
            (selector = document.querySelector('meta[name="csrf-token"]'))) {
            return selector.getAttribute('content');
        }
        return null;
    }
}

var Websocket = /*#__PURE__*/function () {
  function Websocket(options) {
    var _this = this;

    _classCallCheck(this, Websocket);

    this.buffer = [];
    this.listeners = {};
    this.internalListeners = {};
    this.channelBacklog = [];
    this.options = options;
    this.websocket = new WebSocket(options.host);

    this.websocket.onopen = function () {
      while (_this.buffer.length) {
        var message = _this.buffer[0];

        _this.send(message);

        _this.buffer.splice(0, 1);
      }
    };

    this.websocket.onmessage = function (messageEvent) {
      var message = _this.parseMessage(messageEvent.data);

      if (!message) {
        return;
      }

      if (message.channel) {
        console.log("Received event ".concat(message.event, " on channel ").concat(message.channel));

        if (_this.listeners[message.channel] && _this.listeners[message.channel][message.event]) {
          _this.listeners[message.channel][message.event](message.data);
        }

        return;
      }

      if (_this.internalListeners[message.event]) {
        _this.internalListeners[message.event](message.data);
      }
    };

    this.on('whoami', function (_ref) {
      var socketId = _ref.socket_id;
      _this.socketId = socketId;
      console.log("just set socketId to ".concat(socketId));

      while (_this.channelBacklog.length) {
        var channel = _this.channelBacklog[0];

        _this.actuallySubscribe(channel);

        _this.channelBacklog.splice(0, 1);
      }
    });
    this.send({
      event: 'whoami'
    }); // send ping every 60 seconds to keep connection alive

    this.pingInterval = setInterval(function () {
      console.log('Sending ping');

      _this.send({
        event: 'ping'
      });
    }, 60 * 1000);
    return this;
  }

  _createClass(Websocket, [{
    key: "parseMessage",
    value: function parseMessage(body) {
      try {
        return JSON.parse(body);
      } catch (error) {
        console.error(error);
        return undefined;
      }
    }
  }, {
    key: "getSocketId",
    value: function getSocketId() {
      return this.socketId;
    }
  }, {
    key: "socketIsReady",
    value: function socketIsReady() {
      return this.websocket.readyState === this.websocket.OPEN;
    }
  }, {
    key: "send",
    value: function send(message) {
      if (this.socketIsReady()) {
        this.websocket.send(JSON.stringify(message));
        return;
      }

      this.buffer.push(message);
    }
  }, {
    key: "close",
    value: function close() {
      this.internalListeners = {};
      clearInterval(this.pingInterval);
      this.pingInterval = undefined;
      this.websocket.close();
    }
  }, {
    key: "subscribe",
    value: function subscribe(channel) {
      if (this.getSocketId()) {
        this.actuallySubscribe(channel);
      } else {
        this.channelBacklog.push(channel);
      }
    }
  }, {
    key: "actuallySubscribe",
    value: function actuallySubscribe(channel) {
      var _this2 = this;

      if (channel.name.startsWith('private-') || channel.name.startsWith('presence-')) {
        console.log("Sending auth request for channel ".concat(channel.name));
        axios.post(this.options.authEndpoint, {
          socket_id: this.getSocketId(),
          channel_name: channel.name
        }).then(function (response) {
          console.log("Subscribing to channels ".concat(channel.name));

          _this2.send({
            event: 'subscribe',
            data: {
              channel: channel.name,
              auth: response.data.auth
            }
          });
        })["catch"](function (error) {
          console.log("Auth request for channel ".concat(channel.name, " failed"));
          console.error(error);
        });
      } else {
        console.log("Subscribing to channels ".concat(channel.name));
        this.send({
          event: 'subscribe',
          data: {
            channel: channel.name
          }
        });
      }
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(channel) {
      this.send({
        event: 'unsubscribe',
        data: {
          channel: channel.name
        }
      });

      if (this.listeners[channel.name]) {
        delete this.listeners[channel.name];
      }
    }
  }, {
    key: "on",
    value: function on(event) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.internalListeners[event] = callback;
    }
  }, {
    key: "bind",
    value: function bind(channel, event, callback) {
      if (!this.listeners[channel.name]) {
        this.listeners[channel.name] = {};
      }

      this.listeners[channel.name][event] = callback;
    }
  }, {
    key: "unbindEvent",
    value: function unbindEvent(channel, event) {
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (this.internalListeners[event] && (callback === null || this.internalListeners[event] === callback)) {
        delete this.internalListeners[event];
      }
    }
  }]);

  return Websocket;
}();

/**
 * Event name formatter
 */
class EventFormatter {
    /**
     * Create a new class instance.
     */
    constructor(namespace) {
        this.setNamespace(namespace);
    }
    /**
     * Format the given event name.
     */
    format(event) {
        if (event.charAt(0) === '.' || event.charAt(0) === '\\') {
            return event.substr(1);
        }
        else if (this.namespace) {
            event = this.namespace + '.' + event;
        }
        return event.replace(/\./g, '\\');
    }
    /**
     * Set the event namespace.
     */
    setNamespace(value) {
        this.namespace = value;
    }
}

/**
 * This class represents a basic channel.
 */
class Channel {
    /**
     * Listen for a whisper event on the channel instance.
     */
    listenForWhisper(event, callback) {
        return this.listen('.client-' + event, callback);
    }
    /**
     * Listen for an event on the channel instance.
     */
    notification(callback) {
        return this.listen('.Illuminate\\Notifications\\Events\\BroadcastNotificationCreated', callback);
    }
    /**
     * Stop listening for a whisper event on the channel instance.
     */
    stopListeningForWhisper(event, callback) {
        return this.stopListening('.client-' + event, callback);
    }
}

/**
 * This class represents a Pusher channel.
 */

var Channel$1 = /*#__PURE__*/function (_BaseChannel) {
  _inherits(Channel, _BaseChannel);

  var _super = _createSuper(Channel);

  /**
   * Create a new class instance.
   */
  function Channel(socket, name, options) {
    var _this;

    _classCallCheck(this, Channel);

    _this = _super.call(this);
    _this.name = name;
    _this.socket = socket;
    _this.options = options;
    _this.eventFormatter = new EventFormatter(_this.options["namespace"]);

    _this.subscribe();

    return _this;
  }
  /**
   * Subscribe to a Pusher channel.
   */


  _createClass(Channel, [{
    key: "subscribe",
    value: function subscribe() {
      this.socket.subscribe(this);
    }
    /**
     * Unsubscribe from a Pusher channel.
     */

  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      this.socket.unsubscribe(this);
    }
    /**
     * Listen for an event on the channel instance.
     */

  }, {
    key: "listen",
    value: function listen(event, callback) {
      this.on(this.eventFormatter.format(event), callback);
      return this;
    }
    /**
     * Stop listening for an event on the channel instance.
     */

  }, {
    key: "stopListening",
    value: function stopListening(event, callback) {
      this.socket.unbindEvent(this, event, callback);
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription succeeds.
     */

  }, {
    key: "subscribed",
    value: function subscribed(callback) {
      this.on('subscription_succeeded', function () {
        callback();
      });
      return this;
    }
    /**
     * Register a callback to be called anytime a subscription error occurs.
     */

  }, {
    key: "error",
    value: function error(callback) {
      this.on('error', function (status) {
        callback(status);
      });
      return this;
    }
    /**
     * Bind a channel to an event.
     */

  }, {
    key: "on",
    value: function on(event, callback) {
      this.socket.bind(this, event, callback);
      return this;
    }
  }, {
    key: "whisper",
    value: function whisper(event, data) {
      this.socket.send({
        event: event,
        data: data
      });
      return this;
    }
  }, {
    key: "here",
    value: function here(callback) {
      // TODO: implement
      return this;
    }
    /**
     * Listen for someone joining the channel.
     */

  }, {
    key: "joining",
    value: function joining(callback) {
      // TODO: implement
      return this;
    }
    /**
     * Listen for someone leaving the channel.
     */

  }, {
    key: "leaving",
    value: function leaving(callback) {
      // TODO: implement
      return this;
    }
  }]);

  return Channel;
}(Channel);

var broadcaster = function broadcaster(options) {
  return new Connector$1(options);
};
var Connector$1 = /*#__PURE__*/function (_BaseConnector) {
  _inherits(Connector, _BaseConnector);

  var _super = _createSuper(Connector);

  function Connector() {
    var _this;

    _classCallCheck(this, Connector);

    _this = _super.apply(this, arguments);
    /**
     * All of the subscribed channel names.
     */

    _this.channels = {};
    return _this;
  }
  /**
   * Create a fresh Socket.io connection.
   */


  _createClass(Connector, [{
    key: "connect",
    value: function connect() {
      this.socket = new Websocket(this.options);
      return; //
      // this.socket.on('reconnect', () => {
      //     Object.values(this.channels).forEach((channel) => {
      //         channel.subscribe();
      //     });
      // });
      //
      // return this.socket;
    }
    /**
     * Get a channel instance by name.
     */

  }, {
    key: "channel",
    value: function channel(name) {
      if (!this.channels[name]) {
        this.channels[name] = new Channel$1(this.socket, name, this.options);
      }

      return this.channels[name];
    }
    /**
     * Get a private channel instance by name.
     */

  }, {
    key: "privateChannel",
    value: function privateChannel(name) {
      if (!this.channels['private-' + name]) {
        this.channels['private-' + name] = new Channel$1(this.socket, 'private-' + name, this.options);
      }

      return this.channels['private-' + name];
    }
    /**
     * Get a presence channel instance by name.
     */

  }, {
    key: "presenceChannel",
    value: function presenceChannel(name) {
      if (!this.channels['presence-' + name]) {
        this.channels['presence-' + name] = new Channel$1(this.socket, 'presence-' + name, this.options);
      }

      return this.channels['presence-' + name];
    }
    /**
     * Leave the given channel, as well as its private and presence variants.
     */

  }, {
    key: "leave",
    value: function leave(name) {
      var _this2 = this;

      var channels = [name, 'private-' + name, 'presence-' + name];
      channels.forEach(function (name) {
        _this2.leaveChannel(name);
      });
    }
    /**
     * Leave the given channel.
     */

  }, {
    key: "leaveChannel",
    value: function leaveChannel(name) {
      if (this.channels[name]) {
        this.channels[name].unsubscribe();
        delete this.channels[name];
      }
    }
    /**
     * Get the socket ID for the connection.
     */

  }, {
    key: "socketId",
    value: function socketId() {
      return this.socket.getSocketId();
    }
    /**
     * Disconnect socket connection.
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      this.socket.close();
    }
  }]);

  return Connector;
}(Connector);

export { Connector$1 as Connector, broadcaster };
